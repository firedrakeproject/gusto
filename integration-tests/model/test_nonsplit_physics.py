"""
This script tests the non-split timestepper against the split timestepper
using a coupled wave equation, where one of the spatial derivatives
is a physics parametrisation.
One split method is tested, whilst different nonsplit IMEX and explicit time
discretisations are used for the dynamics and physics.
"""

from firedrake import (SpatialCoordinate, PeriodicIntervalMesh, split,
                       norm, Constant, cos, sin, Function, Projector, inner, dx)
from gusto import *
import pytest
from math import pi


class WaveEquation(PrognosticEquationSet):
    u"""Discretises the wave equation as ∂u/∂t + ∇v = 0 and ∂v/∂t + ∇u = 0"""

    def __init__(self, domain, space_names=None, field_names=None):
        """
        Args:
            domain (:class:`Domain`): the model's domain object, containing the
                mesh and the compatible function spaces.
            space_names (:class:`FunctionSpace`): the function spaces that the
                equation's prognostic fields are defined on.
            field_names (str): names of the prognostic fields.
        """

        field_names = ['u', 'v']

        if space_names is None:
            space_names = {'u': 'HDiv', 'v': 'DG'}

        super().__init__(field_names, domain, space_names)

        w, phi = self.tests
        u, v = split(self.X)

        # Non time derivative term of u equation is a physics parametrisation
        mass_form_u = time_derivative(inner(u, w)*dx)
        u_eqn = prognostic(subject(mass_form_u, self.X), 'u')

        # v equation includes a time derivative term and gradient term
        mass_form_v = time_derivative(inner(v, phi)*dx)
        rhs_v = u.dx(0)*phi*dx
        v_eqn = prognostic(subject(mass_form_v + rhs_v, self.X), 'v')

        self.residual = u_eqn + v_eqn


class WaveEquationForcing(PhysicsParametrisation):
    """
    A physics parametrisation for the coupled wave equation. The source term is ∇v in
    the u equation.
    """

    def __init__(self, equation):
        """
        Args:
            equation (:class:`PrognosticEquationSet`): the model's equation.
        """

        label_name = 'wave_forcing'
        super().__init__(equation, label_name, parameters=None)

        self.dt = Constant(0.0)
        self.V = equation.X.function_space()
        self.fields = Function(self.V)

        # -------------------------------------------------------------------- #
        # Extract prognostic variables and test functions
        # -------------------------------------------------------------------- #
        u, v = self.fields.split()
        Vu = u.function_space()
        Vv = v.function_space()
        test_u, test_v = equation.tests

        # Set up funtions for projectors
        self.v_cg = Function(Vu)
        self.grad_v = Function(Vv)

        # Set up source term in mixed function space
        self.source = Function(self.V)

        # First project from DG0 into CG1
        self.projector_cg = Projector(v, self.v_cg)

        # Then project the derivative of v back into DG0
        self.projector_grad = Projector(self.v_cg.dx(0), self.grad_v)

        # Finally project the gradient into the source term in CG1. This must be projected
        # into the u subfunction of the mixed source function
        self.projector_source = Projector(self.grad_v, self.source.subfunctions[0])

        # Set up the expression of source term in the u equation. The u component of the
        # source term must be split using the ufl split function
        source_u_expr = inner(split(self.source)[0], test_u)*dx

        # Add the source term to the equation
        equation.residual += source_label(self.label(subject(source_u_expr,
                                                             self.source), self.evaluate))

    def evaluate(self, x_in, dt, x_out=None):
        """
        Evaluates the source term generated by the wave equation physics forcing

        Args:
            x_in: (:class: 'Function'): the (mixed) field to be evolved.
            dt: (:class: 'Constant'): the timestep, which can be the time
                interval for the scheme.
            x_out: (:class:`Function`, optional): the (mixed) source
                                                  field to be outputed.
        """

        logger.info(f'Evaluating physics parametrisation {self.label.label}')
        self.fields.assign(x_in)

        # Do the projections
        self.projector_cg.project()
        self.projector_grad.project()
        self.projector_source.project()

        # If a source output is provided, assign the source term to it
        if x_out is not None:
            x_out.assign(self.source)


def run_nonsplit_physics(tmpdir, timestepper):
    """
    Runs the coupled wave equation with a ∇v physics parametrisation using different timesteppers.
    """

    # ------------------------------------------------------------------------ #
    # Set up model objects
    # ------------------------------------------------------------------------ #

    # Domain
    dt = 0.001
    tmax = 0.3
    L = 1
    mesh = PeriodicIntervalMesh(100, L)
    domain = Domain(mesh, dt, "CG", 1)

    # Equation
    x = SpatialCoordinate(mesh)[0]
    eqn = WaveEquation(domain)

    # I/O
    output = OutputParameters(dirname=str(tmpdir), dumpfreq=30)
    io = IO(domain, output)

    # Time stepper
    if timestepper == 'split':
        physics_schemes = [(WaveEquationForcing(eqn),
                            RK4(domain))]
        stepper = SplitPhysicsTimestepper(eqn, RK4(domain),
                                          io,
                                          physics_schemes=physics_schemes)
    elif timestepper == 'nonsplit_exp_rk_predictor':
        physics_parametrisation = [WaveEquationForcing(eqn)]
        scheme = RK4(domain, rk_formulation=RungeKuttaFormulation.predictor)
        stepper = Timestepper(eqn, scheme,
                              io, physics_parametrisations=physics_parametrisation)
    elif timestepper == 'nonsplit_exp_rk_increment':
        physics_parametrisation = [WaveEquationForcing(eqn)]
        scheme = RK4(domain, rk_formulation=RungeKuttaFormulation.increment)
        stepper = Timestepper(eqn, scheme,
                              io, physics_parametrisations=physics_parametrisation)
    elif timestepper == 'nonsplit_imex_rk':
        physics_parametrisation = [WaveEquationForcing(eqn)]
        eqn.label_terms(lambda t: not any(t.has_label(time_derivative, source_label)), implicit)
        scheme = IMEX_SSP3(domain)
        stepper = Timestepper(eqn, scheme,
                              io, physics_parametrisations=physics_parametrisation)
    elif timestepper == 'nonsplit_imex_sdc':
        physics_parametrisation = [WaveEquationForcing(eqn)]
        quad_type = "GAUSS"
        M = 2
        k = 2
        qdelta_imp = "LU"
        node_type = "LEGENDRE"
        qdelta_exp = "FE"
        eqn.label_terms(lambda t: not any(t.has_label(time_derivative, source_label)), implicit)
        base_scheme = IMEX_Euler(domain)
        scheme = SDC(base_scheme, domain, M, k, quad_type, node_type, qdelta_imp,
                     qdelta_exp, final_update=True, initial_guess="base")
        stepper = Timestepper(eqn, scheme,
                              io, physics_parametrisations=physics_parametrisation)

    # ------------------------------------------------------------------------ #
    # Initial conditions
    # ------------------------------------------------------------------------ #

    c = 1
    uexp = sin(2*pi*x/L)
    u = stepper.fields("u")
    v = stepper.fields("v")
    u.interpolate(uexp)
    v.interpolate(Constant(0))
    u_final_exp = sin(2*pi*x/L)*cos(2*pi*c*tmax/L)
    u_exact = Function(u.function_space()).project(u_final_exp)

    # ------------------------------------------------------------------------ #
    # Run
    # ------------------------------------------------------------------------ #

    stepper.run(0, tmax=tmax)

    error = norm(stepper.fields('u') - u_exact) / norm(u_exact)
    return error


@pytest.mark.parametrize("timestepper", ["split", "nonsplit_exp_rk_predictor",
                                         "nonsplit_exp_rk_increment",
                                         "nonsplit_imex_rk", "nonsplit_imex_sdc"])
def test_nonsplit_physics(tmpdir, timestepper):
    """
    Test the nonsplit timestepper in the wave equation with source physics.
    """
    if timestepper == 'split':
        # Split has a looser tolerance due to the physics
        # parametrisation not being tightly coupled to the dynamics
        tol = 1e-2
    else:
        tol = 1e-4
    error = run_nonsplit_physics(tmpdir, timestepper)
    assert error < tol, 'The nonsplit timestepper in the coupled wave ' + \
                        'equation with source physics has an error greater than ' + \
                        'the permitted tolerance'
