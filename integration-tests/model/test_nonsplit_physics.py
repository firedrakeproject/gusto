"""
This script tests the non-split timestepper against the split timestepper
using a coupled wave equation, where one of the spatial derivatives
is a physics parametrisation.
One split method is tested, whilst different nonsplit IMEX and explicit time
discretisations are used for the dynamics and physics.
"""

from firedrake import (SpatialCoordinate, PeriodicIntervalMesh, exp, as_vector, split,
                       norm, Constant, conditional, sqrt, VectorFunctionSpace, acos,
                       cos, sin, FunctionSpace, Function, TestFunction, TrialFunction,
                       Projector, inner, dx, grad)
from gusto import *
import pytest
from math import pi
class WaveEquation(PrognosticEquationSet):
    u"""Discretises the wave equation as ∂u/∂t + ∇v = 0 and ∂v/∂t + ∇u = 0"""

    def __init__(self, domain, space_names = None, field_names = None):
        """
        Args:
            domain (:class:`Domain`): the model's domain object, containing the
                mesh and the compatible function spaces.
            space_names (:class:`FunctionSpace`): the function spaces that the
                equation's prognostic fields are defined on.
            field_names (str): names of the prognostic fields.
        """

        field_names = ['u', 'v']

        if space_names is None:
            space_names = {'u': 'HDiv', 'v': 'DG'}

        super().__init__(field_names, domain, space_names)

        w, phi = self.tests
        u, v = split(self.X)

        # Non time derivative term of u equation is a physics parametrisation
        mass_form_u = time_derivative(inner(u, w)*dx)
        u_eqn = prognostic(subject(mass_form_u , self.X), 'u')

        # v equation includes a time derivative term and gradient term
        mass_form_v = time_derivative(inner(v, phi)*dx)
        rhs_v = u.dx(0)*phi*dx
        v_eqn = prognostic(subject(mass_form_v + rhs_v, self.X), 'v')

        self.residual = u_eqn + v_eqn

class WaveEquationForcing(PhysicsParametrisation):
    """
    A physics parametrisation for the coupled wave equation. The source term is ∇v in
    the u equation.
    """

    def __init__(self, equation):
        """
        Args:
            equation (:class:`PrognosticEquationSet`): the model's equation.
        """

        label_name = 'wave_forcing'
        super().__init__(equation, label_name,  parameters=None)

        self.dt = Constant(0.0)
        self.V = equation.X.function_space()
        self.fields = Function(self.V)

        # -------------------------------------------------------------------- #
        # Extract prognostic variables and test functions
        # -------------------------------------------------------------------- #
        u, v = self.fields.split()
        Vu = u.function_space()
        Vv = v.function_space()
        test_u, test_v = equation.tests

        # Set up funtions for projectors
        self.v_cg = Function(Vu)
        self.grad_v = Function(Vv)

        # Set up source term in mixed function space
        self.source = Function(self.V)

        # First project from DG0 into CG1
        self.projector_cg = Projector(v, self.v_cg)

        # Then project the derivative of v back into DG0
        self.projector_grad = Projector(self.v_cg.dx(0), self.grad_v)

        # Finally project the gradient into the source term in CG1. This must be projected
        # into the u subfunction of the mixed source function
        self.projector_source = Projector(self.grad_v, self.source.subfunctions[0])

        # Set up the expression of source term in the u equation. The u component of the
        # source term must be split using the ufl split function
        source_u_expr = inner(split(self.source)[0], test_u)*dx

        # Add the source term to the equation
        equation.residual += source_label(self.label(subject(source_u_expr,
                                                    self.source), self.evaluate))
    def evaluate(self, x_in, dt, x_out = None):
        """
        Evaluates the source term generated by the wave equation physics forcing

        Args:
            x_in: (:class: 'Function'): the (mixed) field to be evolved.
            dt: (:class: 'Constant'): the timestep, which can be the time
                interval for the scheme.
        """

        logger.info(f'Evaluating physics parametrisation {self.label.label}')
        self.fields.assign(x_in)

        # Do the projections
        self.projector_cg.project()
        self.projector_grad.project()
        self.projector_source.project()

        # If a source output is provided, assign the source term to it
        if x_out is not None:
            x_out.assign(self.source)

def run_nonsplit_physics(tmpdir, timestepper):
    """
    Runs the coupled wave equation with a ∇v physics parametrisation using different timesteppers.
    """

    # ------------------------------------------------------------------------ #
    # Set up model objects
    # ------------------------------------------------------------------------ #

    # Domain
    dt = 0.001
    tmax = 0.3
    L = 1
    mesh = PeriodicIntervalMesh(100, L)
    domain = Domain(mesh, dt, "CG", 1)

    # Equation
    x = SpatialCoordinate(mesh)[0]
    eqn = WaveEquation(domain)

    # I/O
    output = OutputParameters(dirname=str(tmpdir), dumpfreq=30)
    io = IO(domain, output)

    # Time stepper
    if timestepper == 'split':
        physics_schemes = [(WaveEquationForcing(eqn),
                            RK4(domain))]
        stepper = SplitPhysicsTimestepper(eqn, RK4(domain),
                                            io,
                                            physics_schemes=physics_schemes)
    elif timestepper == 'nonsplit_exp_rk_predictor':
        WaveEquationForcing(eqn)
        scheme = RK4(domain, rk_formulation=RungeKuttaFormulation.predictor)
        stepper = Timestepper(eqn, scheme,
                                    io)
    elif timestepper == 'nonsplit_exp_rk_increment':
        WaveEquationForcing(eqn)
        scheme = RK4(domain, rk_formulation=RungeKuttaFormulation.increment)
        stepper = Timestepper(eqn, scheme,
                                    io)
    elif timestepper == 'nonsplit_imex_rk':
        WaveEquationForcing(eqn)
        eqn.label_terms(lambda t: not any(t.has_label(time_derivative, source_label)), implicit)
        scheme = IMEX_SSP3(domain)
        stepper = Timestepper(eqn, scheme,
                                io)
    elif timestepper == 'nonsplit_imex_sdc':
        WaveEquationForcing(eqn)
        quad_type = "GAUSS"
        M = 2
        k = 2
        qdelta_imp = "LU"
        node_type = "LEGENDRE"
        qdelta_exp = "FE"
        eqn.label_terms(lambda t: not any(t.has_label(time_derivative, source_label)), implicit)
        base_scheme = IMEX_Euler(domain)
        scheme = SDC(base_scheme, domain, M, k, quad_type, node_type, qdelta_imp,
                    qdelta_exp, final_update=True, initial_guess="base")
        stepper = Timestepper(eqn, scheme,
                                io)

    # ------------------------------------------------------------------------ #
    # Initial conditions
    # ------------------------------------------------------------------------ #

    c = 1
    uexp = sin(2*pi*x/L)
    u = stepper.fields("u")
    v = stepper.fields("v")
    u.interpolate(uexp)
    v.interpolate(Constant(0))
    u_final_exp = sin(2*pi*x/L)*cos(2*pi*c*tmax/L)
    u_exact = Function(u.function_space()).project(u_final_exp)

    # ------------------------------------------------------------------------ #
    # Run
    # ------------------------------------------------------------------------ #

    stepper.run(0, tmax=tmax)

    error = norm(stepper.fields('u') - u_exact) / norm(u_exact)
    return error


@pytest.mark.parametrize("timestepper", ["split", "nonsplit_exp_rk_predictor",
                                         "nonsplit_exp_rk_increment",
                                         "nonsplit_imex_rk", "nonsplit_imex_sdc"])
def test_nonsplit_physics(tmpdir, timestepper):
    """
    Test the nonsplit timestepper in the wave equation with source physics.
    """
    if timestepper == 'split':
    # Split has a looser tolerance due to the physics
    # parametrisation not being tightly coupled to the dynamics
        tol = 1e-2
    else:
        tol = 1e-4
    error = run_nonsplit_physics(tmpdir, timestepper)
    assert error < tol, 'The nonsplit timestepper in the coupled wave' + \
                        'equation with source physics has an error greater than ' + \
                        'the permitted tolerance'
