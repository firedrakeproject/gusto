"""
This script tests the non-split timestepper against the split timestepper
using an forced advection equation with a physics parametrisation.
One split method is tested, whilst different nonsplit IMEX and explicit time
discretisations are used for the dynamics and physics.
"""

from firedrake import (Interpolator, SpatialCoordinate, PeriodicIntervalMesh, exp, as_vector, grad,
                       norm, Constant, conditional, sqrt, VectorFunctionSpace, acos,
                       cos, sin, FunctionSpace, Function, TestFunction, TrialFunction)
from gusto import *
from firedrake.fml import subject
import pytest
from math import pi
class WaveEquation(PrognosticEquation):
    u"""Discretises the advection equation, ∂q/∂t + (u.∇)q = 0"""

    def __init__(self, domain, function_space, field_name, Vu=None):
        """
        Args:
            domain (:class:`Domain`): the model's domain object, containing the
                mesh and the compatible function spaces.
            function_space (:class:`FunctionSpace`): the function space that the
                equation's prognostic is defined on.
            field_name (str): name of the prognostic field.
            Vu (:class:`FunctionSpace`, optional): the function space for the
                velocity field. If this is not specified, uses the HDiv spaces
                set up by the domain. Defaults to None.
        """
        super().__init__(domain, function_space, field_name)

        V = domain.spaces("HDiv")
        u = self.prescribed_fields("u", V)

        test = self.test
        u = self.X
        mass_form = time_derivative(inner(u, test)*dx)

        self.residual = prognostic(subject(mass_form, u), field_name)

class WaveEquationForcing(PhysicsParametrisation):
    """
    """

    def __init__(self, equation, c=None):
        """
        Args:
            equation (:class:`PrognosticEquationSet`): the model's equation.
            c(:class:`BoundaryLayerParameters`): configuration object
                giving the parameters for boundary and surface level schemes.
                Defaults to None, in which case default values are used.
        """

        self.c = c
        label_name = 'wave_forcing'
        super().__init__(equation, label_name,  parameters=None)

        self.X = Function(equation.X.function_space())
        self.dt = Constant(0.0)
        self.V = equation.X.function_space()

        # -------------------------------------------------------------------- #
        # Extract prognostic variables
        # -------------------------------------------------------------------- #

        X = self.X
        test = equation.test
        self.source = Function(self.V)
        source_expr = self.c*test*self.source.dx(0)*dx

        equation.residual -= source(self.label(subject(prognostic(source_expr, 'u'),
                                                    X), self.evaluate))

    def evaluate(self, x_out, x_in, dt):
        """
        Evaluates the source term generated by the physics. This does nothing if
        the implicit formulation is not used.

        Args:
            x_in: (:class: 'Function'): the (mixed) field to be evolved.
            dt: (:class: 'Constant'): the timestep, which can be the time
                interval for the scheme.
        """

        logger.info(f'Evaluating physics parametrisation {self.label.label}')
        self.X.assign(x_in)

        x_out.assign(self.source)


def run_nonsplit_adv_physics2(tmpdir, timestepper):
    """
    Runs the advection equation with a physics parametrisation using different timesteppers.
    """

    # ------------------------------------------------------------------------ #
    # Set up model objects
    # ------------------------------------------------------------------------ #

    # Domain
    dt = 0.01
    tmax = 1
    L = 1
    c = 1.0
    mesh = PeriodicIntervalMesh(50, L)
    domain = Domain(mesh, dt, "CG", 1)

    # Equation
    eqn1 = WaveEquation(domain, domain.spaces("DG"), 'u')
    eqn2 = WaveEquation(domain, domain.spaces("DG"), 'u')
    x = SpatialCoordinate(mesh)[0]

    # Physics schemes
    time_varying = False
    u = Function(domain.spaces("DG"))
    expression1 = c*u.dx(0)
    expression2 = -c*u.dx(0)
    # I/O
    output = OutputParameters(dirname=str(tmpdir), dumpfreq=25)
    io = IO(domain, output)

    # Time stepper
    if timestepper == 'split':
        physics_scheme1 = [(WaveEquationForcing(eqn1, c=c),
                            ForwardEuler(domain))]
        physics_scheme2 = [(WaveEquationForcing(eqn2, c=-c),
                            ForwardEuler(domain))]
        scheme = SSPRK3(domain)
        stepper1 = SplitPhysicsTimestepper(eqn1, scheme,
                                        io, physics_schemes=physics_scheme1)
        stepper2 = SplitPhysicsTimestepper(eqn2, scheme,
                                        io, physics_schemes=physics_scheme2)
    elif timestepper == 'nonsplit_exp_rk_predictor':
        physics_scheme1 = [WaveEquationForcing(eqn1, c=c)]
        physics_scheme2 = [WaveEquationForcing(eqn2, c=-c)]

        scheme = SSPRK3(domain, rk_formulation=RungeKuttaFormulation.predictor)
        stepper1 = Timestepper(eqn1, scheme,
                                      io)
        stepper2 = Timestepper(eqn2, scheme,
                                      io)
    elif timestepper == 'nonsplit_exp_rk_increment':
        physics_scheme1 = [WaveEquationForcing(eqn1, c=c)]
        physics_scheme2 = [WaveEquationForcing(eqn2, c=-c)]

        scheme = SSPRK3(domain, rk_formulation=RungeKuttaFormulation.increment)
        stepper1 = Timestepper(eqn1, scheme,
                                      io)
        stepper2 = Timestepper(eqn2, scheme,
                                      io)
    elif timestepper == 'nonsplit_exp_multistep':
        physics_scheme1 = [WaveEquationForcing(eqn1, c=c)]
        physics_scheme2 = [WaveEquationForcing(eqn2, c=-c)]

        scheme = AdamsBashforth(domain, order=2)
        stepper1 = Timestepper(eqn1, scheme,
                                      io)
        stepper2 = Timestepper(eqn2, scheme,
                                      io)

    # ------------------------------------------------------------------------ #
    # Initial conditions
    # ------------------------------------------------------------------------ #
    uexp = sin(2*pi*x/L)
    u1 = stepper1.fields("u")
    u2 = stepper2.fields("u")
    u1.interpolate(uexp)
    u2.interpolate(uexp)
    u_final_exp = sin(2*pi*x/L)*cos(2*pi*c*tmax/L)
    solution_exact = Function(u1.function_space()).interpolate(u_final_exp)
    # ------------------------------------------------------------------------ #
    # Run
    # ------------------------------------------------------------------------ #

    stepper1.run(0, tmax=tmax)
    stepper2.run(0, tmax=tmax)

    solution = stepper1.fields("u") + stepper2.fields("u")

    error = norm(solution - solution_exact) / norm(solution_exact)
    breakpoint()
    return error


@pytest.mark.parametrize("timestepper", ["split", "nonsplit_exp_rk_predictor",
                                         "nonsplit_exp_rk_increment", "nonsplit_exp_multistep"])
def test_nonsplit_adv_physics2(tmpdir, timestepper):
    """
    Test the nonsplit timestepper in the advection equation with source physics.
    """
    tol = 0.2
    error = run_nonsplit_adv_physics2(tmpdir, timestepper)
    assert error < tol, 'The nonsplit timestepper in the advection' + \
                        'equation with source physics has an error greater than ' + \
                        'the permitted tolerance'
